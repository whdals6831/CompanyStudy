# **SOLID 원칙에 대한 고찰**

* 유지보수성과 확장성에 대한 지침
* 원칙은 독립적이지만 시너지가 있음


#### **1. 단일 책임 원칙 (Single Responsibility Principle)**

* **정의** : 하나의 클래스는 하나의 책임만 가져야 하며, 이 책임은 변경의 이유가 하나여야 한다.
* **의의** : 코드를 단순화하고 모듈화를 촉진하며, 유지보수성을 향상시킨다. 클래스가 명확한 역할을 가지므로 수정이나 테스트 시 영향 범위를 최소화할 수 있다.
* **한계** : 책임 분리가 과도할 경우, 지나치게 작은 클래스들이 생성되어 복잡도가 오히려 증가할 수 있다.


#### **2. 개방-폐쇄 원칙 (Open-Closed Principle)**

* **정의** : 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.
* **의의** : 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 하며, 이는 버그 발생 가능성을 줄이고 시스템 안정성을 보장한다.
* **한계** : 유연성을 확보하기 위한 추상화 작업이 과도할 경우, 코드 가독성이 떨어질 수 있다. 또한, 모든 확장 가능성을 미리 예측하는 것은 현실적으로 어렵다.


#### **3. 리스코프 치환 원칙 (Liskov Substitution Principle)**

* **정의** : 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
* **의의** : 다형성을 통해 클라이언트 코드가 기반 클래스나 인터페이스에 의존하도록 함으로써 코드 재사용성을 높이고 의존성을 줄인다.
* **한계** : 원칙을 따르기 위해 상속 구조를 지나치게 복잡하게 설계할 경우, 오히려 코드의 유연성과 단순성이 저하될 수 있다.


#### **4. 인터페이스 분리 원칙 (Interface Segregation Principle)**

* **정의** : 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
* **의의** : 인터페이스를 세분화하여 불필요한 의존성을 줄이고, 필요한 기능만 구현하게 함으로써 코드의 유연성과 유지보수성을 높인다.
* **한계** : 인터페이스가 지나치게 세분화될 경우, 클래스의 관리와 구현이 복잡해질 수 있다.


#### **5. 의존 역전 원칙 (Dependency Inversion Principle)**

- **정의** : 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.
- **의의** : 의존성을 최소화하여 모듈 간 결합도를 줄이고, 유연한 설계를 가능하게 한다. 특히, 의존성 주입(DI)과 같은 패턴을 통해 구현할 수 있다.
- **한계** : 추상화를 도입하고 의존성 주입을 구현하는 과정에서 초기 설계 복잡도가 증가할 수 있다.


### **SOLID 원칙의 중요성과 적용 시 고려사항**

SOLID 원칙은 코드의 가독성과 재사용성을 극대화하고, 변경에 유연한 소프트웨어를 설계하는 데 중요한 역할을 한다.

특히, 대규모 프로젝트나 팀 기반 개발 환경에서 코드 품질을 유지하는 데 유용하다. 하지만 이 원칙을 무조건적으로 따르는 것은 오히려 과도한 설계 복잡성을 초래할 수 있으며, 현실적인 요구 사항과의 균형이 중요하다.

- **현실적인 트레이드오프** 

    SOLID 원칙을 적용할 때, 프로젝트의 규모와 요구사항에 맞게 유연하게 적용해야 한다. 작은 프로젝트에서는 간단한 구조가 더 효과적일 수 있다.

- **원칙 간 균형**

    각 원칙은 개별적으로 강력하지만, 지나친 추상화나 분리는 다른 원칙과 충돌할 수 있다. 예를 들어, 단일 책임 원칙을 지나치게 따르다 보면 개방-폐쇄 원칙을 위반할 가능성이 생긴다.

- **경험과 학습의 필요성**

    SOLID 원칙을 완벽히 이해하고 적용하기 위해서는 이론뿐만 아니라 실제 프로젝트 경험이 필요하다. 이를 통해 설계의 적정 수준을 판단할 수 있다.

### **결론**

SOLID 원칙은 단순히 코딩 규칙이 아니라, 소프트웨어 설계의 방향성을 제시하는 중요한 철학이다. 그러나 이를 맹목적으로 적용하기보다는 상황에 맞게 유연하게 활용하는 것이 바람직하다.

궁극적으로, SOLID 원칙의 목표는 사람이 이해하고 유지보수하기 쉬운 소프트웨어를 만드는 데 있다는 점을 잊지 말아야 한다.
